# Generated by Django 5.2 on 2025-09-03 21:32

from django.conf import settings
from django.db import migrations, models, connection
import django.db.models.deletion
from django.db.models import Q


# --- helpers -----------------------------------------------------------------

def drop_old_like_indexes_constraints(apps, schema_editor):
    """
    Снести «исторические» уникальные индексы/констрейнты для gallery_like, если они есть.
    Поддерживаемые имена:
      - uniq_like_user_job
      - uniq_like_user_public
      - uniq_like_guest_job
      - uniq_like_guest_public
    """
    vendor = connection.vendor
    table = "gallery_like"
    names = (
        "uniq_like_user_job",
        "uniq_like_user_public",
        "uniq_like_guest_job",
        "uniq_like_guest_public",
    )

    with connection.cursor() as c:
        if vendor == "postgresql":
            # В Postgres пробуем и constraint, и index
            for name in names:
                c.execute(f'ALTER TABLE "{table}" DROP CONSTRAINT IF EXISTS "{name}";')
                c.execute(f'DROP INDEX IF EXISTS "{name}";')
        elif vendor == "mysql":
            # В MySQL IF EXISTS у DROP INDEX не везде доступен — проверяем через SHOW INDEX
            for name in names:
                c.execute(f"SHOW INDEX FROM `{table}` WHERE Key_name = %s;", (name,))
                if c.fetchone():
                    c.execute(f"DROP INDEX `{name}` ON `{table}`;")
        else:
            # SQLite/прочие: мягко пробуем снести индекс
            for name in names:
                try:
                    c.execute(f"DROP INDEX IF EXISTS {name};")
                except Exception:
                    pass


def drop_publicphoto_m2m_tables(apps, schema_editor):
    """
    Снести возможные старые M2M-таблицы для PublicPhoto.categories.
    """
    vendor = connection.vendor
    candidates = (
        "gallery_publicphoto_categories",
        "gallery_publicphoto_category",
        "publicphoto_categories",
    )

    def q(ident: str) -> str:
        # корректные кавычки под конкретный движок
        if vendor == "mysql":
            return f"`{ident}`"
        elif vendor == "postgresql":
            return f'"{ident}"'
        else:  # sqlite и прочие
            return ident

    with connection.cursor() as c:
        for name in candidates:
            try:
                c.execute(f"DROP TABLE IF EXISTS {q(name)};")
            except Exception:
                # если какой-то диалект/состояние не позволяет — просто игнорируем
                pass


# --- migration ---------------------------------------------------------------

class Migration(migrations.Migration):

    dependencies = [
        ("gallery", "0003_alter_like_options_remove_like_uniq_like_user_job_and_more"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        # ----- Meta -----
        migrations.AlterModelOptions(
            name="category",
            options={
                "ordering": ("order", "name"),
                "verbose_name": "Категория",
                "verbose_name_plural": "Категории",
            },
        ),
        migrations.AlterModelOptions(
            name="like",
            options={"verbose_name": "Лайк", "verbose_name_plural": "Лайки"},
        ),

        # ----- Безопасное удаление «уникальных» индексов/констрейнтов (если они есть) -----
        migrations.SeparateDatabaseAndState(
            database_operations=[
                migrations.RunPython(
                    drop_old_like_indexes_constraints,
                    reverse_code=migrations.RunPython.noop,
                )
            ],
            state_operations=[
                migrations.RemoveConstraint(model_name="like", name="uniq_like_user_job"),
                migrations.RemoveConstraint(model_name="like", name="uniq_like_user_public"),
                migrations.RemoveConstraint(model_name="like", name="uniq_like_guest_job"),
                migrations.RemoveConstraint(model_name="like", name="uniq_like_guest_public"),
            ],
        ),

        # ----- Поля Like: удаляем ТОЛЬКО из состояния (в БД — noop) -----
        migrations.SeparateDatabaseAndState(
            database_operations=[],  # noop для БД
            state_operations=[
                migrations.RemoveField(model_name="like", name="guest_session_key"),
            ],
        ),
        migrations.SeparateDatabaseAndState(
            database_operations=[],  # noop для БД
            state_operations=[
                migrations.RemoveField(model_name="like", name="public_photo"),
            ],
        ),

        # ----- PublicPhoto.categories (M2M): в БД удаляем возможные таблицы-связки, состояние убираем -----
        migrations.SeparateDatabaseAndState(
            database_operations=[
                migrations.RunPython(
                    drop_publicphoto_m2m_tables,
                    reverse_code=migrations.RunPython.noop,
                )
            ],
            state_operations=[
                migrations.RemoveField(model_name="publicphoto", name="categories"),
            ],
        ),

        # ----- Новые/изменённые поля -----
        migrations.AddField(
            model_name="category",
            name="is_active",
            field=models.BooleanField(db_index=True, default=True),
        ),
        migrations.AddField(
            model_name="category",
            name="order",
            field=models.PositiveIntegerField(db_index=True, default=0),
        ),
        migrations.AddField(
            model_name="publicphoto",
            name="category",
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                related_name="photos",
                to="gallery.category",
            ),
        ),
        migrations.AlterField(
            model_name="category",
            name="name",
            field=models.CharField(max_length=80, unique=True, verbose_name="Название"),
        ),
        migrations.AlterField(
            model_name="category",
            name="slug",
            field=models.SlugField(max_length=80, unique=True, verbose_name="Слаг"),
        ),
    ]
